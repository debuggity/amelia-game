<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Amelia Sprite Sheet Tester + Mini Game</title>
  <style>
    :root { color-scheme: dark; }
    body {
      margin: 0; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial;
      background: #0b0d12; color: #e7e7e7;
    }
    .wrap { display: grid; grid-template-columns: 380px 1fr; min-height: 100vh; }
    .panel {
      padding: 14px; border-right: 1px solid #1f2430; background: #0f1320;
      overflow: auto;
    }
    h1 { font-size: 16px; margin: 0 0 10px; }
    h2 { font-size: 13px; margin: 14px 0 8px; color: #cfd6ff; }
    .hint { font-size: 12px; color: #aeb6d7; line-height: 1.35; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin: 8px 0; }
    label { font-size: 12px; color: #b8c0e8; display: block; margin-bottom: 4px; }
    input, select, button, textarea {
      width: 100%; box-sizing: border-box;
      background: #0b0f1a; border: 1px solid #222a3a; color: #e7e7e7;
      border-radius: 10px; padding: 8px 10px; font-size: 12px;
      outline: none;
    }
    button { cursor: pointer; background: #141b2c; }
    button:hover { border-color: #3a4770; }
    .btnRow { display: flex; gap: 8px; margin-top: 8px; }
    .btnRow button { width: auto; flex: 1; }
    textarea { min-height: 150px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .stage {
      position: relative; overflow: hidden;
      background: radial-gradient(1100px 700px at 50% 40%, #182042, #070810 60%, #04050a);
    }
    canvas { display: block; width: 100%; height: 100%; }
    .hud {
      position: absolute; top: 10px; left: 10px;
      background: rgba(0,0,0,0.55); border: 1px solid rgba(255,255,255,0.12);
      border-radius: 12px; padding: 10px 12px; font-size: 12px;
      max-width: 560px;
    }
    .hud b { color: #fff; }
    .kbd { padding: 1px 6px; border: 1px solid rgba(255,255,255,0.25); border-radius: 6px; background: rgba(255,255,255,0.08); }
    .gridNote { margin-top: 10px; font-size: 12px; color: #aeb6d7; }
    .small { font-size: 11px; color: #9aa3c8; }
    .warn { color: #ffd38a; }
  </style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>Amelia Sprite Sheet Tester + Mini Game</h1>
    <div class="hint">
      Put <b>amelia-sprite-sheet.png</b> in the same folder as this <b>index.html</b>.
      This tool helps you find the correct grid slicing, then tests your 1..50 frame mapping.
      <div style="margin-top:8px" class="small">
        Local server options:
        <ul style="margin:6px 0 0 18px; padding:0;">
          <li>VS Code Live Server</li>
          <li>Python: <span class="kbd">python -m http.server 8000</span></li>
          <li>Node: <span class="kbd">npx http-server</span></li>
        </ul>
        Then open: <span class="kbd">http://localhost:8000</span>
      </div>
    </div>

    <h2>1) Sprite slicing</h2>
    <div class="row">
      <div>
        <label>Frame width (px)</label>
        <input id="fw" type="number" value="316" min="1" />
      </div>
      <div>
        <label>Frame height (px)</label>
        <input id="fh" type="number" value="345" min="1" />
      </div>
    </div>
    <div class="row">
      <div>
        <label>Columns</label>
        <input id="cols" type="number" value="8" min="1" />
      </div>
      <div>
        <label>Total frames (1..N)</label>
        <input id="totalFrames" type="number" value="50" min="1" />
      </div>
    </div>
    <div class="row">
      <div>
        <label>Margin X (px)</label>
        <input id="mx" type="number" value="0" min="0" />
      </div>
      <div>
        <label>Margin Y (px)</label>
        <input id="my" type="number" value="0" min="0" />
      </div>
    </div>
    <div class="row">
      <div>
        <label>Spacing X (px)</label>
        <input id="sx" type="number" value="0" min="0" />
      </div>
      <div>
        <label>Spacing Y (px)</label>
        <input id="sy" type="number" value="0" min="0" />
      </div>
    </div>

    <div class="btnRow">
      <button id="apply">Apply slicing</button>
      <button id="auto">Auto-detect grid (best effort)</button>
    </div>

    <div class="gridNote">
      <b>Tip:</b> If frames look offset, change <b>Margin</b>. If they overlap, change <b>Spacing</b>.
      If the sheet is a uniform grid but you do not know the cell size, try Auto-detect, then fine tune.
    </div>

    <h2>2) Animation map (by your frame numbers)</h2>
    <div class="hint small">
      Frames are <b>1-indexed</b> here (your list). Edit freely.
      Format: <b>name</b>: [frame, frame, ...]
    </div>
    <textarea id="animJson"></textarea>
    <div class="btnRow">
      <button id="loadMap">Load map</button>
      <button id="resetMap">Reset to your guess</button>
    </div>

    <h2>3) Playback</h2>
    <div class="row">
      <div>
        <label>Animation</label>
        <select id="animSelect"></select>
      </div>
      <div>
        <label>FPS</label>
        <input id="fps" type="number" value="12" min="1" max="60" />
      </div>
    </div>
    <div class="row">
      <div>
        <label>Loop</label>
        <select id="loop">
          <option value="1" selected>Loop</option>
          <option value="0">Play once</option>
        </select>
      </div>
      <div>
        <label>Show grid overlay</label>
        <select id="overlay">
          <option value="1" selected>On</option>
          <option value="0">Off</option>
        </select>
      </div>
    </div>

    <div class="btnRow">
      <button id="play">Play</button>
      <button id="pause">Pause</button>
      <button id="step">Step frame</button>
    </div>

    <h2>How to test all animations</h2>
    <div class="hint">
      <b>Fastest:</b> click <b>Test Mode</b> (cycles every animation automatically).<br/>
      <b>Manual:</b> choose an animation from the dropdown and hit Play.<br/><br/>
      <b>Game controls:</b><br/>
      Move: <span class="kbd">←</span>/<span class="kbd">→</span><br/>
      Jump: <span class="kbd">↑</span><br/>
      Crouch: <span class="kbd">↓</span><br/>
      Punch: <span class="kbd">A</span> (forward punch / upper punch based on crouch)<br/>
      Kick: <span class="kbd">S</span> (low/round/high kick based on crouch + movement)<br/>
      Block: <span class="kbd">Z</span><br/>
      Hadoken: <span class="kbd">Q</span><br/>
      Roll: <span class="kbd">W</span><br/>
      Upper Punch: <span class="kbd">X</span> (hold <span class="kbd">↓</span> for extra upper punch)<br/>
      Test Mode: <span class="kbd">T</span><br/>
      Reset: <span class="kbd">P</span>
      <div style="margin-top:8px">
        <b>Moves:</b><br/>
        <span class="kbd">Q</span> Hadoken · <span class="kbd">W</span> Roll · <span class="kbd">A</span> Forward Punch · <span class="kbd">A</span>+<span class="kbd">↓</span> Down Punch<br/>
        <span class="kbd">A</span>+<span class="kbd">←</span>/<span class="kbd">→</span> Upper Jab Rotation · <span class="kbd">X</span> Upper Punch · <span class="kbd">X</span>+<span class="kbd">↓</span> Extra Upper Punch<br/>
        <span class="kbd">S</span> Round Kick (auto high/low finish) · <span class="kbd">S</span>+<span class="kbd">←</span>/<span class="kbd">→</span> Direct High Kick · <span class="kbd">S</span>+<span class="kbd">↓</span> Low Kick · <span class="kbd">S</span>+back Low Kick Back<br/>
        <span class="kbd">Z</span>+<span class="kbd">S</span> Flying Rotating Kick · <span class="kbd">Z</span> Block (air: jump block)
        <br/>
        Air: <span class="kbd">A</span> up = Jump Kick Up, <span class="kbd">A</span> down = Jump Down Punch · <span class="kbd">S</span> + move = Jump Forward Kick, <span class="kbd">S</span> no move = Forward Jump Kick · <span class="kbd">Z</span>+back = Jump Block Backwards
      </div>
      <div style="margin-top:8px" class="warn">
        If the animations look wrong, the slicing is wrong. Fix slicing first, then revisit frame mapping.
      </div>
    </div>

    <div class="btnRow">
      <button id="testMode">Test Mode (cycle)</button>
      <button id="exportMap">Copy map to clipboard</button>
    </div>
  </div>

  <div class="stage">
    <canvas id="c"></canvas>
    <div class="hud" id="hud"></div>
  </div>
</div>

<script>
(() => {
  const sheetPath = "amelia-sprite-sheet.png";

  const el = (id) => document.getElementById(id);

  const canvas = el("c");
  const ctx = canvas.getContext("2d");

  function resize() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(rect.width * dpr);
    canvas.height = Math.floor(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener("resize", resize);
  resize();

  const hud = el("hud");

  const inputs = {
    fw: el("fw"), fh: el("fh"), cols: el("cols"), totalFrames: el("totalFrames"),
    mx: el("mx"), my: el("my"), sx: el("sx"), sy: el("sy"),
    fps: el("fps"), loop: el("loop"), overlay: el("overlay"),
    animJson: el("animJson"), animSelect: el("animSelect"),
  };

  const defaultMap = () => ({
    idle: [1],
    hadoken: [2,3,4],
    forward_punch: [5],
    upper_punch: [6,7],
    flying_rotating_kick: [8,9,10,11,12,13,14],
    round_kick_starter: [15,16,17],
    idle_block_stance: [18],
    round_kick_high_finish: [19],
    round_kick_low_finish: [20],
    direct_high_kick: [21,22,23,24],
    low_kick_forward: [25],
    jump_kick_up: [26],
    jump_block: [27],
    jump_up: [28],
    jump_forward_kick: [29,30,31,32],
    down_punch: [33,34],
    roll_forward: [35,36,37],
    jump_block_backwards: [38],
    jump_down_punch: [39],
    jump_down: [40],
    forward_jump_kick: [41],
    crouch: [42],
    upper_jab_rotation: [43,44,45,46,47],
    low_kick_back: [48],
    extra_upper_punch: [49,50]
  });

  function pretty(obj) { return JSON.stringify(obj, null, 2); }

  inputs.animJson.value = pretty(defaultMap());

  let sheetImg = new Image();
  sheetImg.src = sheetPath;

  let slicing = {
    fw: +inputs.fw.value, fh: +inputs.fh.value, cols: +inputs.cols.value,
    totalFrames: +inputs.totalFrames.value,
    mx: +inputs.mx.value, my: +inputs.my.value, sx: +inputs.sx.value, sy: +inputs.sy.value,
  };

  let animMap = defaultMap();

  function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

  function frameRect(frameIndex1) {
    const i = frameIndex1 - 1; // 0-based
    const col = i % slicing.cols;
    const row = Math.floor(i / slicing.cols);
    const x = slicing.mx + col * (slicing.fw + slicing.sx);
    const y = slicing.my + row * (slicing.fh + slicing.sy);
    return { x, y, w: slicing.fw, h: slicing.fh };
  }

  function playerRect() {
    const scale = state.renderScale;
    const w = slicing.fw * scale;
    const h = slicing.fh * scale;
    return { x: state.x, y: state.y - h, w, h };
  }

  function startAttack(type, duration = 0.22) {
    state.attackType = type;
    state.attackTimer = duration;
  }

  function aabbOverlap(a, b) {
    return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
  }

  function currentAttackRect() {
    if (!state.attackType || state.attackTimer <= 0) return null;
    const p = playerRect();
    const dir = state.facingLeft ? -1 : 1;
    const punchW = Math.max(20, p.w * 0.28);
    const kickW = Math.max(26, p.w * 0.35);
    const punchH = Math.max(18, p.h * 0.22);
    const kickH = Math.max(18, p.h * 0.25);

    if (state.attackType === "punch") {
      return {
        x: dir === 1 ? p.x + p.w * 0.65 : p.x - punchW * 0.9,
        y: p.y + p.h * 0.38,
        w: punchW,
        h: punchH,
      };
    }
    if (state.attackType === "upper") {
      return {
        x: dir === 1 ? p.x + p.w * 0.55 : p.x - punchW * 0.9,
        y: p.y + p.h * 0.18,
        w: punchW,
        h: punchH * 1.4,
      };
    }
    if (state.attackType === "kick") {
      return {
        x: dir === 1 ? p.x + p.w * 0.6 : p.x - kickW * 0.9,
        y: p.y + p.h * 0.55,
        w: kickW,
        h: kickH,
      };
    }
    if (state.attackType === "lowkick") {
      return {
        x: dir === 1 ? p.x + p.w * 0.55 : p.x - kickW * 0.9,
        y: p.y + p.h * 0.7,
        w: kickW,
        h: kickH * 0.9,
      };
    }
    return null;
  }

  function drawFrame(frameIndex1, dx, dy, scale = 1, flipX = false) {
    const r = frameRect(frameIndex1);
    ctx.save();
    ctx.translate(dx, dy);
    ctx.scale(flipX ? -1 : 1, 1);
    const ox = flipX ? -r.w * scale : 0;
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(sheetImg, r.x, r.y, r.w, r.h, ox, 0, r.w * scale, r.h * scale);
    ctx.restore();
  }

  function drawGridOverlay() {
    if (inputs.overlay.value !== "1") return;
    const fw = slicing.fw, fh = slicing.fh, cols = slicing.cols;
    const total = slicing.totalFrames;
    const rows = Math.ceil(total / cols);

    const scale = state.renderScale;
    const ox = state.sheetPreviewX;
    const oy = state.sheetPreviewY;

    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.lineWidth = 1;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const idx = r * cols + c + 1;
        if (idx > total) continue;
        const x = ox + c * fw * scale;
        const y = oy + r * fh * scale;
        ctx.strokeStyle = "rgba(255,255,255,0.25)";
        ctx.strokeRect(x, y, fw * scale, fh * scale);
        ctx.fillStyle = "rgba(255,255,255,0.15)";
        ctx.fillText(String(idx), x + 4, y + 12);
      }
    }
    ctx.restore();
  }

  // Tiny physics and state
  const state = {
    x: 200, y: 260,
    vx: 0, vy: 0,
    onGround: true,
    facingLeft: false,
    currentAnim: "idle",
    animFramePtr: 0,
    animTime: 0,
    paused: false,
    testMode: false,
    testAnimNames: [],
    testIndex: 0,
    testTimer: 0,
    renderScale: 2.0,
    groundY: 300,
    attackType: null,
    attackTimer: 0,
    roundKickPending: false,

    // preview of sheet as a minimap for slicing sanity
    sheetPreviewX: 20,
    sheetPreviewY: 330,
  };

  const boxes = [
    { x: 420, y: 0, w: 44, h: 44, vx: 0, vy: 0, hitTimer: 0 },
    { x: 520, y: 0, w: 44, h: 44, vx: 0, vy: 0, hitTimer: 0 },
    { x: 620, y: 0, w: 44, h: 44, vx: 0, vy: 0, hitTimer: 0 },
  ];

  const projectiles = [];

  function setAnim(name, reset = true) {
    if (!animMap[name]) return;
    if (state.currentAnim !== name) {
      state.currentAnim = name;
      if (name !== "round_kick_starter") state.roundKickPending = false;
      if (reset) {
        state.animFramePtr = 0;
        state.animTime = 0;
      }
      inputs.animSelect.value = name;
    }
  }

  function currentFrame() {
    const frames = animMap[state.currentAnim] || [1];
    const i = clamp(state.animFramePtr, 0, frames.length - 1);
    return frames[i];
  }

  function updateAnim(dt) {
    const fps = clamp(+inputs.fps.value || 12, 1, 60);
    const frames = animMap[state.currentAnim] || [1];
    const frameDur = 1 / fps;
    const loopEnabled = inputs.loop.value === "1" &&
      !(state.roundKickPending && state.currentAnim === "round_kick_starter");

    state.animTime += dt;

    while (state.animTime >= frameDur) {
      state.animTime -= frameDur;

      if (frames.length <= 1) return;

      if (state.animFramePtr < frames.length - 1) {
        state.animFramePtr++;
      } else {
        if (loopEnabled) {
          state.animFramePtr = 0;
        }
      }
    }
  }

  function stepAnimOnce() {
    const frames = animMap[state.currentAnim] || [1];
    if (frames.length <= 1) return;
    if (state.animFramePtr < frames.length - 1) state.animFramePtr++;
    else state.animFramePtr = 0;
  }

  // Keyboard
  const keys = new Set();
  window.addEventListener("keydown", (e) => {
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(e.key)) e.preventDefault();
    const k = e.key.toLowerCase();
    keys.add(k);

    // one-shot triggers
    if (k === "t") toggleTestMode();
    if (k === "p") resetPlayer();
    if (k === "q") {
      setAnim("hadoken", true);
      startAttack("hadoken", 0.15);
      const p = playerRect();
      const dir = state.facingLeft ? -1 : 1;
      const size = Math.max(14, p.w * 0.12);
      projectiles.push({
        x: dir === 1 ? p.x + p.w * 0.75 : p.x - size,
        y: p.y + p.h * 0.5,
        w: size,
        h: size,
        vx: dir * 420,
        active: true,
      });
    }
    if (k === "w") {
      setAnim("roll_forward", true);
      startAttack("kick", 0.18);
    }
    if (k === "z") {
      if (!state.onGround) {
        const movingBack = (state.facingLeft && keys.has("arrowright")) || (!state.facingLeft && keys.has("arrowleft"));
        setAnim(movingBack ? "jump_block_backwards" : "jump_block", true);
      } else {
        setAnim("idle_block_stance", true);
      }
    }
    if (k === "a") {
      if (!state.onGround) {
        if (state.vy < 0) {
          setAnim("jump_kick_up", true);
          startAttack("kick", 0.2);
        } else {
          setAnim("jump_down_punch", true);
          startAttack("upper", 0.2);
        }
      } else if (keys.has("arrowdown")) {
        setAnim("down_punch", true);
        startAttack("upper", 0.2);
      } else if (keys.has("arrowleft") || keys.has("arrowright")) {
        setAnim("upper_jab_rotation", true);
        startAttack("punch", 0.2);
      } else {
        setAnim("forward_punch", true);
        startAttack("punch", 0.2);
      }
    }
    if (k === "s") {
      const left = keys.has("arrowleft");
      const right = keys.has("arrowright");
      const crouch = keys.has("arrowdown");
      const back = (state.facingLeft && right) || (!state.facingLeft && left);
      if (!state.onGround) {
        if (left || right) {
          setAnim("jump_forward_kick", true);
        } else {
          setAnim("forward_jump_kick", true);
        }
        startAttack("kick", 0.22);
      } else if (crouch) {
        setAnim("low_kick_forward", true);
        startAttack("lowkick", 0.22);
      } else if (back) {
        setAnim("low_kick_back", true);
        startAttack("lowkick", 0.22);
      } else if (left || right) {
        setAnim("direct_high_kick", true);
        startAttack("kick", 0.22);
      } else if (keys.has("z")) {
        setAnim("flying_rotating_kick", true);
        startAttack("kick", 0.24);
      } else {
        state.roundKickPending = true;
        setAnim("round_kick_starter", true);
        startAttack("kick", 0.2);
      }
    }
    if (k === "x") {
      if (keys.has("arrowdown")) setAnim("extra_upper_punch", true);
      else setAnim("upper_punch", true);
      startAttack("upper", 0.22);
    }
  });
  window.addEventListener("keyup", (e) => keys.delete(e.key.toLowerCase()));

  function resetPlayer() {
    state.x = 200; state.y = state.groundY; state.vx = 0; state.vy = 0; state.onGround = true;
    state.facingLeft = false;
    state.testMode = false;
    state.attackType = null;
    state.attackTimer = 0;
    projectiles.length = 0;
    for (let i = 0; i < boxes.length; i++) {
      boxes[i].x = 420 + i * 100;
      boxes[i].vx = 0;
      boxes[i].vy = 0;
      boxes[i].y = state.groundY - boxes[i].h;
    }
    setAnim("idle", true);
  }

  function toggleTestMode() {
    state.testMode = !state.testMode;
    state.testTimer = 0;
    state.testIndex = 0;
    state.testAnimNames = Object.keys(animMap);
    if (state.testMode && state.testAnimNames.length) {
      setAnim(state.testAnimNames[0], true);
    }
  }

  // Auto-detect grid (best effort):
  // Scans alpha sums per column/row looking for near-empty gutters.
  async function autoDetectGrid() {
    if (!sheetImg.complete) return;

    const tmp = document.createElement("canvas");
    tmp.width = sheetImg.naturalWidth;
    tmp.height = sheetImg.naturalHeight;
    const tctx = tmp.getContext("2d", { willReadFrequently: true });
    tctx.drawImage(sheetImg, 0, 0);

    const img = tctx.getImageData(0, 0, tmp.width, tmp.height);
    const { data, width, height } = img;

    function colAlphaSum(x) {
      let s = 0;
      for (let y = 0; y < height; y++) s += data[(y * width + x) * 4 + 3];
      return s;
    }
    function rowAlphaSum(y) {
      let s = 0;
      for (let x = 0; x < width; x++) s += data[(y * width + x) * 4 + 3];
      return s;
    }

    const colSums = new Uint32Array(width);
    const rowSums = new Uint32Array(height);
    for (let x = 0; x < width; x++) colSums[x] = colAlphaSum(x);
    for (let y = 0; y < height; y++) rowSums[y] = rowAlphaSum(y);

    const colMin = Math.min(...colSums);
    const rowMin = Math.min(...rowSums);
    const colThresh = colMin + (Math.max(...colSums) - colMin) * 0.02;
    const rowThresh = rowMin + (Math.max(...rowSums) - rowMin) * 0.02;

    function findGaps(arr, thresh) {
      const gaps = [];
      let inGap = false, start = 0;
      for (let i = 0; i < arr.length; i++) {
        if (arr[i] <= thresh) {
          if (!inGap) { inGap = true; start = i; }
        } else if (inGap) {
          inGap = false;
          gaps.push([start, i - 1]);
        }
      }
      if (inGap) gaps.push([start, arr.length - 1]);
      return gaps;
    }

    const colGaps = findGaps(colSums, colThresh);
    const rowGaps = findGaps(rowSums, rowThresh);

    // Estimate spacing as median gap width (ignoring huge edge gaps).
    function medianGapWidth(gaps, len) {
      const widths = gaps
        .map(([a,b]) => b - a + 1)
        .filter(w => w > 0 && w < len * 0.2);
      if (!widths.length) return 0;
      widths.sort((a,b) => a-b);
      return widths[Math.floor(widths.length / 2)];
    }

    const estSX = medianGapWidth(colGaps, width);
    const estSY = medianGapWidth(rowGaps, height);

    // Estimate frame width by looking at distances between gap centers.
    function centers(gaps) {
      return gaps.map(([a,b]) => Math.floor((a + b) / 2));
    }
    function diffs(xs) {
      const ds = [];
      for (let i = 1; i < xs.length; i++) ds.push(xs[i] - xs[i-1]);
      return ds;
    }
    function median(arr) {
      if (!arr.length) return 0;
      const a = [...arr].sort((x,y)=>x-y);
      return a[Math.floor(a.length/2)];
    }

    const colCenters = centers(colGaps);
    const rowCenters = centers(rowGaps);
    const estPitchX = median(diffs(colCenters)); // frame+spacing
    const estPitchY = median(diffs(rowCenters));

    // Heuristic: frame size = pitch - spacing
    const estFW = estPitchX ? Math.max(1, estPitchX - estSX) : slicing.fw;
    const estFH = estPitchY ? Math.max(1, estPitchY - estSY) : slicing.fh;

    // Margin guess: first non-empty region start
    function firstNonGapStart(gaps) {
      if (!gaps.length) return 0;
      // If there's an initial gap starting at 0, use its end+1 as margin
      const [a,b] = gaps[0];
      if (a === 0) return b + 1;
      return 0;
    }
    const estMX = firstNonGapStart(colGaps);
    const estMY = firstNonGapStart(rowGaps);

    // Columns guess: how many frames fit across
    const usableW = width - estMX;
    const colsGuess = estFW ? Math.max(1, Math.floor((usableW + estSX) / (estFW + estSX))) : slicing.cols;

    // Apply guesses
    inputs.fw.value = String(estFW);
    inputs.fh.value = String(estFH);
    inputs.sx.value = String(estSX);
    inputs.sy.value = String(estSY);
    inputs.mx.value = String(estMX);
    inputs.my.value = String(estMY);
    inputs.cols.value = String(colsGuess);

    applySlicing();
  }

  function applySlicing() {
    slicing = {
      fw: +inputs.fw.value, fh: +inputs.fh.value, cols: +inputs.cols.value,
      totalFrames: +inputs.totalFrames.value,
      mx: +inputs.mx.value, my: +inputs.my.value, sx: +inputs.sx.value, sy: +inputs.sy.value,
    };
    // keep player scale reasonable relative to frame size
    state.renderScale = slicing.fw <= 80 ? 3.0 : slicing.fw <= 140 ? 2.0 : 1.5;
    // keep sprite fully visible with a small top padding
    state.groundY = Math.max(300, slicing.fh * state.renderScale + 20);
    if (state.onGround) state.y = state.groundY;
    for (let i = 0; i < boxes.length; i++) {
      boxes[i].y = state.groundY - boxes[i].h;
    }
  }

  function loadMapFromTextarea() {
    let parsed;
    try {
      parsed = JSON.parse(inputs.animJson.value);
    } catch (e) {
      alert("Animation JSON parse error: " + e.message);
      return;
    }
    // basic validation: arrays of ints
    for (const [k, v] of Object.entries(parsed)) {
      if (!Array.isArray(v) || v.some(n => !Number.isFinite(n))) {
        alert(`Bad frames for "${k}". Must be an array of numbers.`);
        return;
      }
    }
    animMap = parsed;
    refreshAnimSelect();
    setAnim(Object.keys(animMap)[0] || "idle", true);
  }

  function refreshAnimSelect() {
    inputs.animSelect.innerHTML = "";
    for (const name of Object.keys(animMap)) {
      const opt = document.createElement("option");
      opt.value = name;
      opt.textContent = name;
      inputs.animSelect.appendChild(opt);
    }
  }

  // Buttons
  el("apply").addEventListener("click", applySlicing);
  el("auto").addEventListener("click", autoDetectGrid);
  el("loadMap").addEventListener("click", () => { loadMapFromTextarea(); });
  el("resetMap").addEventListener("click", () => {
    animMap = defaultMap();
    inputs.animJson.value = pretty(animMap);
    refreshAnimSelect();
    setAnim("idle", true);
  });
  el("play").addEventListener("click", () => { state.paused = false; });
  el("pause").addEventListener("click", () => { state.paused = true; });
  el("step").addEventListener("click", () => { stepAnimOnce(); });
  el("testMode").addEventListener("click", () => toggleTestMode());
  el("exportMap").addEventListener("click", async () => {
    try {
      await navigator.clipboard.writeText(inputs.animJson.value);
      alert("Copied animation map JSON to clipboard.");
    } catch {
      alert("Clipboard copy failed. You can manually copy from the textbox.");
    }
  });

  inputs.animSelect.addEventListener("change", () => setAnim(inputs.animSelect.value, true));

  // Mini-game behavior: chooses idle/run/jump/crouch defaults unless you triggered a move
  function desiredBaseAnim() {
    const left = keys.has("arrowleft");
    const right = keys.has("arrowright");
    const jump = keys.has("arrowup");
    const crouch = keys.has("arrowdown");
    const block = keys.has("z");

    if (block && state.onGround && animMap.idle_block_stance) return "idle_block_stance";
    if (crouch && state.onGround && animMap.crouch) return "crouch";
    if (!state.onGround) {
      if (state.vy < 0 && animMap.jump_up) return "jump_up";
      if (state.vy >= 0 && animMap.jump_down) return "jump_down";
      return "jump_up";
    }
    // no explicit walk/run animation in your list, so we just idle while moving
    return "idle";
  }

  function updatePhysics(dt) {
    const left = keys.has("arrowleft");
    const right = keys.has("arrowright");
    const jump = keys.has("arrowup");

    const speed = 220;
    state.vx = 0;
    if (left) { state.vx = -speed; state.facingLeft = true; }
    if (right) { state.vx = speed; state.facingLeft = false; }

    if (jump && state.onGround) {
      state.vy = -460;
      state.onGround = false;
      if (animMap.jump_up) setAnim("jump_up", true);
    }

    // gravity
    state.vy += 980 * dt;

    state.x += state.vx * dt;
    state.y += state.vy * dt;

    // ground
    const groundY = state.groundY;
    if (state.y >= groundY) {
      state.y = groundY;
      state.vy = 0;
      state.onGround = true;
    }

    state.x = clamp(state.x, 40, canvas.getBoundingClientRect().width - 40);
  }

  function updateCombat(dt) {
    if (state.attackTimer > 0) state.attackTimer = Math.max(0, state.attackTimer - dt);
    if (state.attackTimer === 0) state.attackType = null;

    const hitRect = currentAttackRect();
    const dir = state.facingLeft ? -1 : 1;
    const knockX = 320 * dir;

    for (const box of boxes) {
      if (box.hitTimer > 0) box.hitTimer = Math.max(0, box.hitTimer - dt);
      if (hitRect && box.hitTimer === 0) {
        if (aabbOverlap(hitRect, box)) {
          box.vx += knockX;
          box.vy -= 220;
          box.hitTimer = 0.25;
        }
      }
    }

    for (const proj of projectiles) {
      if (!proj.active) continue;
      proj.x += proj.vx * dt;
      for (const box of boxes) {
        if (box.hitTimer > 0) continue;
        if (aabbOverlap(proj, box)) {
          box.vx += knockX * 0.8;
          box.vy -= 200;
          box.hitTimer = 0.2;
          proj.active = false;
          break;
        }
      }
      if (proj.x < -100 || proj.x > canvas.getBoundingClientRect().width + 100) {
        proj.active = false;
      }
    }
    for (let i = projectiles.length - 1; i >= 0; i--) {
      if (!projectiles[i].active) projectiles.splice(i, 1);
    }

    for (const box of boxes) {
      box.vy += 980 * dt;
      box.x += box.vx * dt;
      box.y += box.vy * dt;
      if (box.y + box.h >= state.groundY) {
        box.y = state.groundY - box.h;
        box.vy = 0;
        box.vx *= 0.86;
        if (Math.abs(box.vx) < 6) box.vx = 0;
      }
      if (box.x < 40) { box.x = 40; box.vx *= -0.4; }
      const maxX = canvas.getBoundingClientRect().width - 40 - box.w;
      if (box.x > maxX) { box.x = maxX; box.vx *= -0.4; }
    }
  }

  function updateTestMode(dt) {
    if (!state.testMode) return;
    const names = state.testAnimNames;
    if (!names.length) return;

    state.testTimer += dt;
    // switch every 1.1s
    if (state.testTimer >= 1.1) {
      state.testTimer = 0;
      state.testIndex = (state.testIndex + 1) % names.length;
      setAnim(names[state.testIndex], true);
    }
  }

  function draw() {
    const w = canvas.getBoundingClientRect().width;
    const h = canvas.getBoundingClientRect().height;

    // clear
    ctx.clearRect(0, 0, w, h);

    // ground
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.08)";
    ctx.fillRect(0, state.groundY, w, 2);
    ctx.restore();

    // boxes
    ctx.save();
    for (const box of boxes) {
      ctx.fillStyle = box.hitTimer > 0 ? "rgba(255,140,80,0.9)" : "rgba(120,180,255,0.85)";
      ctx.fillRect(box.x, box.y, box.w, box.h);
      ctx.strokeStyle = "rgba(0,0,0,0.4)";
      ctx.strokeRect(box.x, box.y, box.w, box.h);
    }
    ctx.restore();

    // player
    const frame = currentFrame();
    const scale = state.renderScale;
    drawFrame(frame, state.x, state.y - slicing.fh * scale, scale, state.facingLeft);

    // projectiles
    ctx.save();
    ctx.fillStyle = "rgba(120,210,255,0.95)";
    for (const proj of projectiles) {
      if (!proj.active) continue;
      ctx.fillRect(proj.x, proj.y, proj.w, proj.h);
    }
    ctx.restore();

    // sprite-sheet mini preview (helps you see slicing)
    if (sheetImg.complete) {
      const prevScale = Math.min(0.35, 320 / sheetImg.naturalWidth);
      const px = state.sheetPreviewX;
      const py = state.sheetPreviewY;
      ctx.save();
      ctx.globalAlpha = 0.85;
      ctx.imageSmoothingEnabled = false;
      ctx.drawImage(sheetImg, px, py, sheetImg.naturalWidth * prevScale, sheetImg.naturalHeight * prevScale);
      ctx.restore();

      // grid overlay drawn over preview area, not the full image
      // We simulate a grid aligned to your slicing settings in a separate pass
      if (inputs.overlay.value === "1") {
        const fw = slicing.fw * prevScale;
        const fh = slicing.fh * prevScale;
        const cols = slicing.cols;
        const total = slicing.totalFrames;
        const rows = Math.ceil(total / cols);

        const ox = px + slicing.mx * prevScale;
        const oy = py + slicing.my * prevScale;

        ctx.save();
        ctx.globalAlpha = 0.55;
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(255,255,255,0.35)";
        ctx.fillStyle = "rgba(255,255,255,0.35)";
        ctx.font = "11px system-ui";

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const idx = r * cols + c + 1;
            if (idx > total) continue;
            const x = ox + c * (slicing.fw + slicing.sx) * prevScale;
            const y = oy + r * (slicing.fh + slicing.sy) * prevScale;
            ctx.strokeRect(x, y, slicing.fw * prevScale, slicing.fh * prevScale);
            ctx.fillText(String(idx), x + 3, y + 11);
          }
        }
        ctx.restore();
      }
    }

    // HUD
    const rect = frameRect(frame);
    hud.innerHTML = `
      <div><b>Anim:</b> ${state.currentAnim}</div>
      <div><b>Frame:</b> ${frame} <span style="opacity:0.7">(sheet x=${Math.round(rect.x)}, y=${Math.round(rect.y)}, w=${rect.w}, h=${rect.h})</span></div>
      <div><b>Slicing:</b> fw=${slicing.fw}, fh=${slicing.fh}, cols=${slicing.cols}, mx=${slicing.mx}, my=${slicing.my}, sx=${slicing.sx}, sy=${slicing.sy}, total=${slicing.totalFrames}</div>
      <div><b>Mode:</b> ${state.testMode ? "Test Mode (cycling)" : "Game / Manual"}</div>
      <div class="small" style="margin-top:6px; opacity:0.9">
        Quick: <span class="kbd">T</span> cycle all, <span class="kbd">Q</span> hadoken, <span class="kbd">A</span> punch, <span class="kbd">S</span> kick, <span class="kbd">Z</span> block, <span class="kbd">W</span> roll, <span class="kbd">X</span> upper punch, <span class="kbd">P</span> reset
      </div>
    `;
  }

  // Main loop
  let last = performance.now();
  function tick(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;

    if (!state.paused) {
      updateTestMode(dt);

      if (!state.testMode) {
        updatePhysics(dt);

        // If current anim finished (play once mode), fall back to base anim
        const frames = animMap[state.currentAnim] || [1];
        const atEnd = state.animFramePtr >= frames.length - 1;
        const isOneShot = inputs.loop.value === "0";

        // If we're not in a one-shot, we still allow base anim to override when idle-ish
        const base = desiredBaseAnim();

        // If user isn't holding a special move key, gently return to base
        const specialHeld = keys.has("h") || keys.has("j") || keys.has("k") || keys.has("l") || keys.has("r");
        if (!specialHeld && (state.currentAnim !== base) && (isOneShot ? atEnd : true)) {
          setAnim(base, true);
        } else if (!specialHeld && state.currentAnim === "idle" && base !== "idle") {
          setAnim(base, true);
        }
      }

      updateCombat(dt);
      updateAnim(dt);

      if (state.roundKickPending && state.currentAnim === "round_kick_starter") {
        const frames = animMap[state.currentAnim] || [1];
        if (state.animFramePtr >= frames.length - 1) {
          const crouch = keys.has("arrowdown");
          const finish = crouch ? "round_kick_low_finish" : "round_kick_high_finish";
          if (animMap[finish]) {
            setAnim(finish, true);
            startAttack(crouch ? "lowkick" : "kick", 0.22);
          }
          state.roundKickPending = false;
        }
      }
    }

    draw();
    requestAnimationFrame(tick);
  }

  // Init
  sheetImg.onload = () => {
    applySlicing();
    refreshAnimSelect();
    setAnim("idle", true);
    requestAnimationFrame(tick);
  };

  sheetImg.onerror = () => {
    hud.innerHTML = `
      <div class="warn"><b>Could not load:</b> ${sheetPath}</div>
      <div class="small" style="margin-top:6px">
        Make sure <b>amelia-sprite-sheet.png</b> is in the same folder as <b>index.html</b>, and run a local server (not file://).
      </div>
    `;
  };
})();
</script>
</body>
</html>
